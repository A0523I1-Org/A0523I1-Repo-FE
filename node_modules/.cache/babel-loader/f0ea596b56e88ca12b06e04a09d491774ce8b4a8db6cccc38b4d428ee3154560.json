{"ast":null,"code":"import { containsEllipsis, createEllipsis, getLastPage, isEllipsis, isNav, isPageWithNumber, compositionMatches, compositionMatchesEnd } from './compositionItem.js';\nimport { findLastIndex } from './helpers/util.js';\n/**\n * @public\n */\nexport function* dropEllipsis(initialComposition, metaData) {\n  const indicesToDrop = [];\n  if (metaData?.appliedBehaviours?.includes(dropFirstAndLast)) {\n    // 1, 2 => …, 2 => 2\n    const firstPageIndex = initialComposition.findIndex(item => isPageWithNumber(item, 1));\n    if (compositionMatches(initialComposition, firstPageIndex, [1, 2])) {\n      indicesToDrop.push(firstPageIndex);\n    }\n    // n-1, n => n-1, … => n-1\n    /** last page */\n    const n = getLastPage(initialComposition);\n    const lastPageIndex = findLastIndex(initialComposition, item => isPageWithNumber(item, n));\n    if (compositionMatchesEnd(initialComposition, lastPageIndex, [n - 1, n])) {\n      indicesToDrop.push(lastPageIndex);\n    }\n  }\n  if (containsEllipsis(initialComposition) || indicesToDrop.length > 0) {\n    yield initialComposition.filter((item, index) => !isEllipsis(item) && !indicesToDrop.includes(index));\n  }\n}\n/**\n * @public\n */\nexport function* dropNav(initialComposition) {\n  yield initialComposition.filter(item => !isNav(item));\n}\n/**\n * @public\n */\nexport function* dropFirstAndLast(initialComposition, metaData) {\n  const ellipsisDropped = metaData?.appliedBehaviours?.includes(dropEllipsis);\n  let composition = initialComposition.slice();\n  /**\n   * normal\n   * 1*                 1*\n   * 1, 2*              1, 2*\n   * 1, 2, 3*           1, 2, 3*\n   * 1, 2, 3, 4*        …, 3, 4*\n   * 1, …, p, p+1*      …, p, p+1* (p>=4)\n   *\n   * after dropEllipsis\n   * 1*                 1*\n   * 1, 2*              1, 2*\n   * 1, 2, 3*           2, 3*\n   * 1, 2, 3, 4*        3, 4*\n   * 1, p, p+1*         p, p+1  (p>=4)\n   */\n  const firstPageIndex = composition.findIndex(item => isPageWithNumber(item, 1));\n  if (ellipsisDropped) {\n    if (compositionMatches(composition, firstPageIndex, [1, 2, 3, '*'])) {\n      composition.splice(firstPageIndex, 2);\n    } else if (compositionMatches(composition, firstPageIndex, [1, '#', '*'])) {\n      composition.splice(firstPageIndex, 1);\n    }\n  } else {\n    if (compositionMatches(composition, firstPageIndex, [1, 2, 3, '*'])) {\n      composition.splice(firstPageIndex, 2, createEllipsis('L'));\n    } else if (compositionMatches(composition, firstPageIndex, [1, '…', '#'])) {\n      composition.splice(firstPageIndex, 1);\n    }\n  }\n  /** last page */\n  const n = getLastPage(composition);\n  const lastPageIndex = findLastIndex(composition, item => isPageWithNumber(item, n));\n  if (ellipsisDropped) {\n    if (compositionMatchesEnd(composition, lastPageIndex, ['*', n - 2, n - 1, n])) {\n      composition.splice(lastPageIndex - 1, 2);\n    } else if (compositionMatchesEnd(composition, lastPageIndex, ['*', '#', n])) {\n      composition.splice(lastPageIndex, 1);\n    }\n  } else {\n    if (compositionMatchesEnd(composition, lastPageIndex, ['*', n - 2, n - 1, n])) {\n      composition.splice(lastPageIndex - 1, 2, createEllipsis('R'));\n    } else if (compositionMatchesEnd(composition, lastPageIndex, ['#', '…', n])) {\n      composition.splice(lastPageIndex, 1);\n    }\n  }\n  if (initialComposition.length !== composition.length) {\n    yield composition;\n  }\n}\n/**\n * @public\n */\nexport function* dropEllipsisThenNav(initialComposition) {\n  if (containsEllipsis(initialComposition)) {\n    yield initialComposition.filter(item => !isEllipsis(item) && !isNav(item));\n    yield initialComposition.filter(item => !isEllipsis(item));\n  } else {\n    yield initialComposition.filter(item => !isNav(item));\n  }\n}\n/**\n * @public\n */\nexport function* dropNavThenEllipsis(initialComposition) {\n  if (containsEllipsis(initialComposition)) {\n    yield initialComposition.filter(item => !isEllipsis(item) && !isNav(item));\n  }\n  yield initialComposition.filter(item => !isNav(item));\n}\n/**\n * When combining NarrowBehaviours the behaviours will be applied in order:\n * the first behaviour will be used before subsequent behaviours\n * Compositions yielded from combineBehaviours will initially have\n * all behaviours applied in their narrowest form and then work through\n * each behaviour in turn (from last to first)\n */\n/**\n * Combine two or more narrowBehaviours\n * @public\n */\nexport const combine = (...behaviours) => initialComposition => combineRecursive(behaviours, [], initialComposition);\nfunction* combineRecursive(behaviours, previousBehaviours, initialComposition) {\n  // if no behaviours then we are done\n  if (behaviours.length === 0) return;\n  const [firstBehaviour, ...remainingBehaviours] = behaviours;\n  const firstBehaviourCompositions = firstBehaviour(initialComposition, {\n    appliedBehaviours: previousBehaviours\n  });\n  const firstResult = firstBehaviourCompositions.next();\n  if (firstResult.done) {\n    // if this behaviour did not yield anything then just move on to the next behaviour\n    yield* combineRecursive(remainingBehaviours, [...previousBehaviours, firstBehaviour], initialComposition);\n  } else {\n    const firstComposition = firstResult.value;\n    // the first composition will be the most reduced\n    // this will be the composition for lower priority behaviours to\n    // be applied on top of\n    yield* combineRecursive(remainingBehaviours, [...previousBehaviours, firstBehaviour], firstComposition);\n    // then yield this composition without any other behaviours applied\n    yield firstComposition;\n    // then yield the remaining compositions from this behaviour\n    yield* firstBehaviourCompositions;\n  }\n}","map":{"version":3,"names":["containsEllipsis","createEllipsis","getLastPage","isEllipsis","isNav","isPageWithNumber","compositionMatches","compositionMatchesEnd","findLastIndex","dropEllipsis","initialComposition","metaData","indicesToDrop","appliedBehaviours","includes","dropFirstAndLast","firstPageIndex","findIndex","item","push","n","lastPageIndex","length","filter","index","dropNav","ellipsisDropped","composition","slice","splice","dropEllipsisThenNav","dropNavThenEllipsis","combine","behaviours","combineRecursive","previousBehaviours","firstBehaviour","remainingBehaviours","firstBehaviourCompositions","firstResult","next","done","firstComposition","value"],"sources":["D:/Code_Gym/Data GitHub/final_module/Developer/A0523I1-Repo-FE/node_modules/react-responsive-pagination/dist/narrowBehaviour.js"],"sourcesContent":["import { containsEllipsis, createEllipsis, getLastPage, isEllipsis, isNav, isPageWithNumber, compositionMatches, compositionMatchesEnd, } from './compositionItem.js';\nimport { findLastIndex } from './helpers/util.js';\n/**\n * @public\n */\nexport function* dropEllipsis(initialComposition, metaData) {\n    const indicesToDrop = [];\n    if (metaData?.appliedBehaviours?.includes(dropFirstAndLast)) {\n        // 1, 2 => …, 2 => 2\n        const firstPageIndex = initialComposition.findIndex(item => isPageWithNumber(item, 1));\n        if (compositionMatches(initialComposition, firstPageIndex, [1, 2])) {\n            indicesToDrop.push(firstPageIndex);\n        }\n        // n-1, n => n-1, … => n-1\n        /** last page */\n        const n = getLastPage(initialComposition);\n        const lastPageIndex = findLastIndex(initialComposition, item => isPageWithNumber(item, n));\n        if (compositionMatchesEnd(initialComposition, lastPageIndex, [n - 1, n])) {\n            indicesToDrop.push(lastPageIndex);\n        }\n    }\n    if (containsEllipsis(initialComposition) || indicesToDrop.length > 0) {\n        yield initialComposition.filter((item, index) => !isEllipsis(item) && !indicesToDrop.includes(index));\n    }\n}\n/**\n * @public\n */\nexport function* dropNav(initialComposition) {\n    yield initialComposition.filter(item => !isNav(item));\n}\n/**\n * @public\n */\nexport function* dropFirstAndLast(initialComposition, metaData) {\n    const ellipsisDropped = metaData?.appliedBehaviours?.includes(dropEllipsis);\n    let composition = initialComposition.slice();\n    /**\n     * normal\n     * 1*                 1*\n     * 1, 2*              1, 2*\n     * 1, 2, 3*           1, 2, 3*\n     * 1, 2, 3, 4*        …, 3, 4*\n     * 1, …, p, p+1*      …, p, p+1* (p>=4)\n     *\n     * after dropEllipsis\n     * 1*                 1*\n     * 1, 2*              1, 2*\n     * 1, 2, 3*           2, 3*\n     * 1, 2, 3, 4*        3, 4*\n     * 1, p, p+1*         p, p+1  (p>=4)\n     */\n    const firstPageIndex = composition.findIndex(item => isPageWithNumber(item, 1));\n    if (ellipsisDropped) {\n        if (compositionMatches(composition, firstPageIndex, [1, 2, 3, '*'])) {\n            composition.splice(firstPageIndex, 2);\n        }\n        else if (compositionMatches(composition, firstPageIndex, [1, '#', '*'])) {\n            composition.splice(firstPageIndex, 1);\n        }\n    }\n    else {\n        if (compositionMatches(composition, firstPageIndex, [1, 2, 3, '*'])) {\n            composition.splice(firstPageIndex, 2, createEllipsis('L'));\n        }\n        else if (compositionMatches(composition, firstPageIndex, [1, '…', '#'])) {\n            composition.splice(firstPageIndex, 1);\n        }\n    }\n    /** last page */\n    const n = getLastPage(composition);\n    const lastPageIndex = findLastIndex(composition, item => isPageWithNumber(item, n));\n    if (ellipsisDropped) {\n        if (compositionMatchesEnd(composition, lastPageIndex, ['*', n - 2, n - 1, n])) {\n            composition.splice(lastPageIndex - 1, 2);\n        }\n        else if (compositionMatchesEnd(composition, lastPageIndex, ['*', '#', n])) {\n            composition.splice(lastPageIndex, 1);\n        }\n    }\n    else {\n        if (compositionMatchesEnd(composition, lastPageIndex, ['*', n - 2, n - 1, n])) {\n            composition.splice(lastPageIndex - 1, 2, createEllipsis('R'));\n        }\n        else if (compositionMatchesEnd(composition, lastPageIndex, ['#', '…', n])) {\n            composition.splice(lastPageIndex, 1);\n        }\n    }\n    if (initialComposition.length !== composition.length) {\n        yield composition;\n    }\n}\n/**\n * @public\n */\nexport function* dropEllipsisThenNav(initialComposition) {\n    if (containsEllipsis(initialComposition)) {\n        yield initialComposition.filter(item => !isEllipsis(item) && !isNav(item));\n        yield initialComposition.filter(item => !isEllipsis(item));\n    }\n    else {\n        yield initialComposition.filter(item => !isNav(item));\n    }\n}\n/**\n * @public\n */\nexport function* dropNavThenEllipsis(initialComposition) {\n    if (containsEllipsis(initialComposition)) {\n        yield initialComposition.filter(item => !isEllipsis(item) && !isNav(item));\n    }\n    yield initialComposition.filter(item => !isNav(item));\n}\n/**\n * When combining NarrowBehaviours the behaviours will be applied in order:\n * the first behaviour will be used before subsequent behaviours\n * Compositions yielded from combineBehaviours will initially have\n * all behaviours applied in their narrowest form and then work through\n * each behaviour in turn (from last to first)\n */\n/**\n * Combine two or more narrowBehaviours\n * @public\n */\nexport const combine = (...behaviours) => initialComposition => combineRecursive(behaviours, [], initialComposition);\nfunction* combineRecursive(behaviours, previousBehaviours, initialComposition) {\n    // if no behaviours then we are done\n    if (behaviours.length === 0)\n        return;\n    const [firstBehaviour, ...remainingBehaviours] = behaviours;\n    const firstBehaviourCompositions = firstBehaviour(initialComposition, {\n        appliedBehaviours: previousBehaviours,\n    });\n    const firstResult = firstBehaviourCompositions.next();\n    if (firstResult.done) {\n        // if this behaviour did not yield anything then just move on to the next behaviour\n        yield* combineRecursive(remainingBehaviours, [...previousBehaviours, firstBehaviour], initialComposition);\n    }\n    else {\n        const firstComposition = firstResult.value;\n        // the first composition will be the most reduced\n        // this will be the composition for lower priority behaviours to\n        // be applied on top of\n        yield* combineRecursive(remainingBehaviours, [...previousBehaviours, firstBehaviour], firstComposition);\n        // then yield this composition without any other behaviours applied\n        yield firstComposition;\n        // then yield the remaining compositions from this behaviour\n        yield* firstBehaviourCompositions;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}